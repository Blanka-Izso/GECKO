function model = applyKcatConstraints(model,kcatSource,kcatComplex,kcatSubs,updateRxns)
% applyKcatConstraints
%   Applies kcat-derived enzyme constraints to an ec-model. Existing enzyme
%   constraints are first removed, and new constraints are defined based on
%   the content of model.ec.kcat.
%
% Input:
%   model       ec-model that was generated by makeEcModel, or loaded from
%               an earlier run. Not compatible with ec-models generated by
%               earlier GECKO versions (pre 3.0).
%   kcatSource  which kcat should be used if model.ec.kcat contains
%               multiple values for the same enzyme-gene pair. Explanation
%               below. Input should be provided as string (e.g. 'any').
%               any     all kcat sources are considered (default)
%               dlkcat  DLKcat derived kcat values are used
%               kcatdb  kcat values derived from BRENDA and SABIO-RK
%                       databases are used
%               manual  manual curated kcat values are used
%               If 'manual' should be preferred, followed by 'kcatdb' and
%               'dlkcat', kcatSource can be specified as 
%               'manual>kcatdb>dlkcat'. Variations of this are possible.
%   kcatComplex which kcat should be used if multiple subunits are defined,
%               can either be 'max' (default), 'min' or 'median'.
%   updateRxns  if not all enzyme constraints should be updated, this can
%               be given as either a logical vector of length
%               model.ec.rxns, a vector of model.ec.rxns indices, or a
%               (cell array of) string(s) with model.ec.rxns identifiers.
%
% Output:
%   model         ec-model where reactions are constrained by enzyme usage
%                 if a kcat value was provided for the reaction-enzyme pair
%                 in model.ec.kcat
%
%   By default, the highest kcat value is used if the same reaction-enzyme
%   pair has multiple kcat values defined in model.ec.kat. This can occur
%   if model.ec.kcat contains e.g. values from different sources (e.g.
%   DLKcat, BRENDA, manual curation), or because different values are
%   provided for each substrate of the reaction (typical for DLKcat).
%
%   Kcat source preference can be specified in kcatSource, but if still
%   multiple kcat values are found, then the highest value will be used. If
%   only providing one option, then only kcat values matching that criteria
%   will be used. If no kcat value is available for a particular reaction-
%   enzyme pair (or, if an enzyme complex, for none of the subunits), then
%   no enzyme constraints will be applied for that reaction. Alternatively,
%   an order of preferred sources can be provided in kcatSource.
%
%   TODO: refer to additional function to apply constraints for those
%         reaction-enzyme pairs without kcat values.
%
% Usage: model = applyKcatConstraints(model,kcatSource,kcatComplex);

if nargin<2
    kcatSource = 'any';
end
if nargin<3
    kcatComplex = 'max';
end
if nargin<4
    kcatSubs = 'max';
end
if nargin<5
    updateRxns = true(numel(model.ec.rxns),1);
elseif isnumeric(updateRxns)
    updateRxnsLog = false(numel(model.ec.rxns),1);
    updateRxnsLog(updateRxns) = true;
    updateRxns = updateRxnsLog;
elseif iscellstr(updateRxns) || ischar(updateRxns) || isstring(updateRxns)
    updateRxnsIds = convertCharArray(updateRxns);
    updateRxns = ismember(model.ec.rxns,updateRxnsIds);
end
    
if ~isfield(model,'ec')
    error(['No model.ec structure could be found: the provided model is'...
           ' not a valid GECKO3 ec-model. First run makeEcModel(model).'])
end
if all(model.ec.kcat==0)
    warning('No kcat values are provided in model.ec.kcat, model remains unchanged.')
    return
end

%Clear existing incorporation of enzyme usage
protMetIdx = startsWith(model.mets,'prot_') & ~strcmp(model.mets,'prot_pool');
metabolRxn = unique(model.ec.rxns(updateRxns));
metabolRxn = ismember(model.rxns,metabolRxn);
model.S(protMetIdx,metabolRxn) = 0;
model.ec.inModel(updateRxns)   = false;

%Select which kcats to be used. updateKcats will first contain all relevant
%kcat values, but the ones that should not be used are replaced by zeros.
%Per reaction, first select which sources should be considered; then loop
%through each enzyme and choose the min/max/median value for that enzyme;
%and finally chose the min/max/median value across subunits of the same
%reaction.

[ecRxns,~,ecRxnsIdx]=unique(model.ec.rxns(updateRxns),'stable');
updateKcats = zeros(numel(model.ec.kcat),1);
updateKcats(updateRxns) = model.ec.kcat(updateRxns);
for i=1:numel(ecRxns)
    multipleKcatEntries = updateRxns(ecRxnsIdx == i);
    switch kcatSource
        case {'dlkcat','kcatdb','manual'}
            kcatSources = model.ec.source(multipleKcatEntries);
            sourceKcats = strcmp(kcatSources,kcatSource);
        case 'any'
            sourceKcats = true(numel(multipleKcatEntries),1);
        otherwise % parse 'kcatSource' to extract preferred order
            sourceOrder = strsplit(kcatSource,'>');
            kcatSources = model.ec.source(multipleKcatEntries);
            for j=1:numel(sourceOrder)
                sourceKcats = strcmp(kcatSources,sourceOrder(j));
                if any(sourceKcats)
                    break %If match is found, do not try other sources
                end
            end
    end
    updateKcats(multipleKcatEntries(~sourceKcats)) = 0;
    multipleKcatEntries(~sourceKcats)=[]; % Remove sources not to consider

    %For each subunit, first choose the maximum value (for instance from
    %different substrates)
    [subunit,firstIdx,subunitIdx] = unique(model.ec.enzyme(multipleKcatEntries),'stable');
    for j=1:numel(subunit)
        sameSubunit = multipleKcatEntries(subunitIdx==j);
        switch kcatSubs
            case 'max'
                updateKcats(sameSubunit(1))=max(updateKcats(sameSubunit),[],'omitnan');
            case 'min'
                nonZeroKcat = updateKcats(sameSubunit);
                updateKcats(sameSubunit(1))=min(nonZeroKcat(nonZeroKcat>0),[],'omitnan');
            case 'median'
                nonZeroKcat = updateKcats(sameSubunit);                
                updateKcats(sameSubunit(1))=median(nonZeroKcat(nonZeroKcat>0),'omitnan');
        end
        %Set new kcat value at the position of the first occurence of the
        %subunit, and remove all other kcats for this subunit (for this rxn)
        sameSubunit(1)=[];
        updateKcats(sameSubunit)=0; %Remove non-summarized kcat value
    end
    multipleKcatEntries=multipleKcatEntries(firstIdx);
    switch kcatComplex
        case 'max'
            updateKcats(multipleKcatEntries) = max(updateKcats(multipleKcatEntries),[],'omitnan');
        case 'min'
            nonZeroKcat = updateKcats(multipleKcatEntries);
            updateKcats(multipleKcatEntries) = min(nonZeroKcat(nonZeroKcat>0),[],'omitnan');
        case 'median'
            nonZeroKcat = updateKcats(multipleKcatEntries);
            updateKcats(multipleKcatEntries) = median(nonZeroKcat(nonZeroKcat>0),'omitnan');
    end
    %updateKcats now contains identical kcat values for each subunit,
    %without duplications (from different sources or substrates)
end

%Populate S-matrix with selected kcats
[~,newKcatRxns] = ismember(model.ec.rxns(updateKcats>0),model.rxns);
[~,newKcatMets] = ismember(strcat('prot_',model.ec.enzyme(updateKcats>0)),model.mets);
linearIndices   = sub2ind(size(model.S),newKcatMets,newKcatRxns);

newKcats    = updateKcats(updateKcats>0);
newSubunits = model.ec.subunits(updateKcats>0);
newKcats    = newKcats * 3600; %per second -> per hour
newKcats    = newKcats.^-1; %Inverse: hours per reaction
newKcats    = newKcats*1000; %In umol instead of mmol
newKcats    = newKcats .* newSubunits; %Multicopy subunits.

model.S(linearIndices)=newKcats;
end

